"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.execTool = exports.commandExists = exports.runGoTool = exports.goBinPath = exports.installGoBin = void 0;
const tslib_1 = require("tslib");
const path_1 = tslib_1.__importDefault(require("path"));
const fs_1 = tslib_1.__importDefault(require("fs"));
const child_process_1 = require("child_process");
const coc_nvim_1 = require("coc.nvim");
const which_1 = tslib_1.__importDefault(require("which"));
const config_1 = require("./config");
const child_process_2 = tslib_1.__importDefault(require("child_process"));
////////////////////////////////////////////////////////////////////////////////
async function installGoBin(source, force = false) {
    const name = goBinName(source);
    if (!force && await goBinExists(name)) {
        return true;
    }
    const statusItem = coc_nvim_1.workspace.createStatusBarItem(90, { progress: true });
    statusItem.text = `Installing '${name}'`;
    statusItem.show();
    const success = await goRun(`get ${source}@latest`);
    if (success) {
        coc_nvim_1.workspace.showMessage(`Installed '${name}'`);
    }
    else {
        coc_nvim_1.workspace.showMessage(`Failed to install '${name}'`, 'error');
    }
    statusItem.hide();
    return success;
}
exports.installGoBin = installGoBin;
async function goBinPath(source) {
    const name = goBinName(source);
    return path_1.default.join(await config_1.configDir('bin'), name);
}
exports.goBinPath = goBinPath;
async function runGoTool(name, args = []) {
    const bin = await goBinPath(name);
    return new Promise((resolve) => {
        const p = child_process_1.spawn(bin, args);
        let out = "";
        p.stdout.on('data', (data) => out += data);
        p.on("close", code => resolve([code, out]));
    });
}
exports.runGoTool = runGoTool;
async function commandExists(command) {
    return new Promise((resolve) => { which_1.default(command, (err) => resolve(err == null)); });
}
exports.commandExists = commandExists;
////////////////////////////////////////////////////////////////////////////////
async function goBinExists(source) {
    const name = goBinName(source);
    const bin = await goBinPath(name);
    return new Promise((resolve) => fs_1.default.open(bin, 'r', (err) => resolve(err === null)));
}
async function goRun(args) {
    const gopath = await config_1.configDir('tools');
    const gobin = await config_1.configDir('bin');
    const env = { GOBIN: gobin, GOPATH: gopath, GO111MODULE: 'on' };
    const cmd = `go ${args}`;
    const opts = {
        env: Object.assign({}, process.env, env),
        cwd: gopath
    };
    try {
        await coc_nvim_1.runCommand(cmd, opts);
    }
    catch (ex) {
        coc_nvim_1.workspace.showMessage(ex);
        return false;
    }
    return true;
}
async function execTool(source, args, input) {
    const [bin, name] = await Promise.all([
        goBinPath(source),
        goBinName(source)
    ]);
    if (!await commandExists(bin)) {
        await installGoBin(source);
    }
    return new Promise((resolve, reject) => {
        const p = child_process_2.default.execFile(bin, args, { cwd: coc_nvim_1.workspace.cwd }, async (err, stdout, stderr) => {
            if (err && err.code === "ENOENT") {
                return reject(`Error: Command ${name} not found! Run "CocCommand go.install.${name}" to install it and try again.`);
            }
            if (err) {
                return reject(stderr.toString());
            }
            return resolve(stdout.toString());
        });
        if (p.pid) {
            p.stdin.end(input);
        }
    });
}
exports.execTool = execTool;
////////////////////////////////////////////////////////////////////////////////
function goBinName(source) {
    return source.replace(/\/\.\.\.$/, '').split('/').pop();
}
//# sourceMappingURL=tools.js.map